/*
* AUTOGENERATED FILE. DO NOT EDIT IT
* Generated by "generate_jsb.py -c Parse_jsb.ini" on 2013-12-25
* Script version: v0.6
*/
#import "jsb_config.h"
#if JSB_INCLUDE_PARSE


// needed for callbacks from objective-c to JS
#import <objc/runtime.h>
#import "JRSwizzle.h"

#import "jsfriendapi.h"
#import "jsb_config.h"
#import "jsb_core.h"

#import "jsb_parse_classes.h"


/*
 * PFObject
 */
#pragma mark - PFObject

JSClass* JSB_PFObject_class = NULL;
JSObject* JSB_PFObject_object = NULL;
// Constructor
JSBool JSB_PFObject_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_PFObject createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_PFObject_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (PFObject)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_PFObject_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_PFObject *proxy = [[JSB_PFObject alloc] initWithJSObject:obj class:[PFObject class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: PFACL* (o)
JSBool JSB_PFObject_ACL(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	PFACL* ret_val;

	PFObject *real = (PFObject*) [proxy realObj];
	ret_val = [real ACL ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: NSArray*, NSString*
// Ret value: void (None)
JSBool JSB_PFObject_addObjectsFromArray_forKey_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSArray* arg0; NSString* arg1; 

	ok &= JSB_jsval_to_NSArray( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	PFObject *real = (PFObject*) [proxy realObj];
	[real addObjectsFromArray:(NSArray*)arg0 forKey:(NSString*)arg1  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSArray*, NSString*
// Ret value: void (None)
JSBool JSB_PFObject_addUniqueObjectsFromArray_forKey_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSArray* arg0; NSString* arg1; 

	ok &= JSB_jsval_to_NSArray( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	PFObject *real = (PFObject*) [proxy realObj];
	[real addUniqueObjectsFromArray:(NSArray*)arg0 forKey:(NSString*)arg1  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSArray* (array)
JSBool JSB_PFObject_allKeys(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSArray* ret_val;

	PFObject *real = (PFObject*) [proxy realObj];
	ret_val = [real allKeys ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSArray( cx, (NSArray*) ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_PFObject_delete(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	PFObject *real = (PFObject*) [proxy realObj];
	ret_val = [real delete ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: NSArray*
// Ret value: BOOL (b)
JSBool JSB_PFObject_deleteAll__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSArray* arg0; 

	ok &= JSB_jsval_to_NSArray( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	BOOL ret_val;

	ret_val = [PFObject deleteAll:(NSArray*)arg0  ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: NSArray*
// Ret value: void (None)
JSBool JSB_PFObject_deleteAllInBackground__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSArray* arg0; 

	ok &= JSB_jsval_to_NSArray( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	[PFObject deleteAllInBackground:(NSArray*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_PFObject_deleteEventually(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	PFObject *real = (PFObject*) [proxy realObj];
	[real deleteEventually ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_PFObject_deleteInBackground(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	PFObject *real = (PFObject*) [proxy realObj];
	[real deleteInBackground ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_PFObject_fetch(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	PFObject *real = (PFObject*) [proxy realObj];
	[real fetch ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSArray*
// Ret value: void (None)
JSBool JSB_PFObject_fetchAll__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSArray* arg0; 

	ok &= JSB_jsval_to_NSArray( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	[PFObject fetchAll:(NSArray*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSArray*
// Ret value: void (None)
JSBool JSB_PFObject_fetchAllIfNeeded__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSArray* arg0; 

	ok &= JSB_jsval_to_NSArray( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	[PFObject fetchAllIfNeeded:(NSArray*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: PFObject* (o)
JSBool JSB_PFObject_fetchIfNeeded(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	PFObject* ret_val;

	PFObject *real = (PFObject*) [proxy realObj];
	ret_val = [real fetchIfNeeded ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: void (None)
JSBool JSB_PFObject_incrementKey_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	PFObject *real = (PFObject*) [proxy realObj];
	[real incrementKey:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: None (None)
JSBool JSB_PFObject_init(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	PFObject *real = [(PFObject*)[proxy.klass alloc] init ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: None (None)
JSBool JSB_PFObject_initWithClassName_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	PFObject *real = [(PFObject*)[proxy.klass alloc] initWithClassName:(NSString*)arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_PFObject_isDataAvailable(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	PFObject *real = (PFObject*) [proxy realObj];
	ret_val = [real isDataAvailable ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_PFObject_isDirty(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	PFObject *real = (PFObject*) [proxy realObj];
	ret_val = [real isDirty ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: BOOL (b)
JSBool JSB_PFObject_isDirtyForKey_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	BOOL ret_val;

	PFObject *real = (PFObject*) [proxy realObj];
	ret_val = [real isDirtyForKey:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: PFObject* (o)
JSBool JSB_PFObject_object_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	PFObject* ret_val;

	ret_val = [PFObject object ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSString* (S)
JSBool JSB_PFObject_objectId(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSString* ret_val;

	PFObject *real = (PFObject*) [proxy realObj];
	ret_val = [real objectId ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSString( cx, (NSString*) ret_val ));

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: PFObject* (o)
JSBool JSB_PFObject_objectWithClassName__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	PFObject* ret_val;

	ret_val = [PFObject objectWithClassName:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: NSString*, NSDictionary*
// Ret value: PFObject* (o)
JSBool JSB_PFObject_objectWithClassName_dictionary__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSDictionary* arg1; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSDictionary( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	PFObject* ret_val;

	ret_val = [PFObject objectWithClassName:(NSString*)arg0 dictionary:(NSDictionary*)arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: NSString*, NSString*
// Ret value: PFObject* (o)
JSBool JSB_PFObject_objectWithoutDataWithClassName_objectId__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	PFObject* ret_val;

	ret_val = [PFObject objectWithoutDataWithClassName:(NSString*)arg0 objectId:(NSString*)arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: PFObject* (o)
JSBool JSB_PFObject_objectWithoutDataWithObjectId__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	PFObject* ret_val;

	ret_val = [PFObject objectWithoutDataWithObjectId:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSString* (S)
JSBool JSB_PFObject_parseClassName(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSString* ret_val;

	PFObject *real = (PFObject*) [proxy realObj];
	ret_val = [real parseClassName ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSString( cx, (NSString*) ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: PFQuery* (o)
JSBool JSB_PFObject_query_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	PFQuery* ret_val;

	ret_val = [PFObject query ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_PFObject_registerSubclass_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	[PFObject registerSubclass ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: PFRelation* (o)
JSBool JSB_PFObject_relationforKey_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	PFRelation* ret_val;

	PFObject *real = (PFObject*) [proxy realObj];
	ret_val = [real relationforKey:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: void (None)
JSBool JSB_PFObject_removeObjectForKey_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	PFObject *real = (PFObject*) [proxy realObj];
	[real removeObjectForKey:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSArray*, NSString*
// Ret value: void (None)
JSBool JSB_PFObject_removeObjectsInArray_forKey_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSArray* arg0; NSString* arg1; 

	ok &= JSB_jsval_to_NSArray( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	PFObject *real = (PFObject*) [proxy realObj];
	[real removeObjectsInArray:(NSArray*)arg0 forKey:(NSString*)arg1  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_PFObject_save(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	PFObject *real = (PFObject*) [proxy realObj];
	ret_val = [real save ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: NSArray*
// Ret value: BOOL (b)
JSBool JSB_PFObject_saveAll__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSArray* arg0; 

	ok &= JSB_jsval_to_NSArray( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	BOOL ret_val;

	ret_val = [PFObject saveAll:(NSArray*)arg0  ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: NSArray*
// Ret value: void (None)
JSBool JSB_PFObject_saveAllInBackground__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSArray* arg0; 

	ok &= JSB_jsval_to_NSArray( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	[PFObject saveAllInBackground:(NSArray*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_PFObject_saveEventually(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	PFObject *real = (PFObject*) [proxy realObj];
	[real saveEventually ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_PFObject_saveInBackground(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	PFObject *real = (PFObject*) [proxy realObj];
	[real saveInBackground ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: PFACL*
// Ret value: void (None)
JSBool JSB_PFObject_setACL_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	PFObject *real = (PFObject*) [proxy realObj];
	[real setACL:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: void (None)
JSBool JSB_PFObject_setObjectId_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	PFObject *real = (PFObject*) [proxy realObj];
	[real setObjectId:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

void JSB_PFObject_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_PFObject_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_PFObject_class->name = name;
	JSB_PFObject_class->addProperty = JS_PropertyStub;
	JSB_PFObject_class->delProperty = JS_DeletePropertyStub;
	JSB_PFObject_class->getProperty = JS_PropertyStub;
	JSB_PFObject_class->setProperty = JS_StrictPropertyStub;
	JSB_PFObject_class->enumerate = JS_EnumerateStub;
	JSB_PFObject_class->resolve = JS_ResolveStub;
	JSB_PFObject_class->convert = JS_ConvertStub;
	JSB_PFObject_class->finalize = JSB_PFObject_finalize;
	JSB_PFObject_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getACL", JSB_PFObject_ACL, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("addObjectsFromArrayForKey", JSB_PFObject_addObjectsFromArray_forKey_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("addUniqueObjectsFromArrayForKey", JSB_PFObject_addUniqueObjectsFromArray_forKey_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("allKeys", JSB_PFObject_allKeys, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("delete", JSB_PFObject_delete, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("deleteEventually", JSB_PFObject_deleteEventually, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("deleteInBackground", JSB_PFObject_deleteInBackground, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("fetch", JSB_PFObject_fetch, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("fetchIfNeeded", JSB_PFObject_fetchIfNeeded, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("incrementKey", JSB_PFObject_incrementKey_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("init", JSB_PFObject_init, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithClassName", JSB_PFObject_initWithClassName_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("isDataAvailable", JSB_PFObject_isDataAvailable, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("isDirty", JSB_PFObject_isDirty, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("isDirtyForKey", JSB_PFObject_isDirtyForKey_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getObjectId", JSB_PFObject_objectId, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getParseClassName", JSB_PFObject_parseClassName, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("relationforKey", JSB_PFObject_relationforKey_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("removeObjectForKey", JSB_PFObject_removeObjectForKey_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("removeObjectsInArrayForKey", JSB_PFObject_removeObjectsInArray_forKey_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("save", JSB_PFObject_save, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("saveEventually", JSB_PFObject_saveEventually, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("saveInBackground", JSB_PFObject_saveInBackground, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setACL", JSB_PFObject_setACL_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setObjectId", JSB_PFObject_setObjectId_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_PFObject_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("deleteAll", JSB_PFObject_deleteAll__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("deleteAllInBackground", JSB_PFObject_deleteAllInBackground__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("fetchAll", JSB_PFObject_fetchAll__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("fetchAllIfNeeded", JSB_PFObject_fetchAllIfNeeded__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("object", JSB_PFObject_object_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("objectWithClassName", JSB_PFObject_objectWithClassName__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("objectWithClassNameDictionary", JSB_PFObject_objectWithClassName_dictionary__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("objectWithoutDataWithClassNameObjectId", JSB_PFObject_objectWithoutDataWithClassName_objectId__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("objectWithoutDataWithObjectId", JSB_PFObject_objectWithoutDataWithObjectId__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("query", JSB_PFObject_query_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("registerSubclass", JSB_PFObject_registerSubclass_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("saveAll", JSB_PFObject_saveAll__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("saveAllInBackground", JSB_PFObject_saveAllInBackground__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_PFObject_object = JS_InitClass(cx, globalObj, JSB_NSObject_object, JSB_PFObject_class, JSB_PFObject_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_PFObject

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_PFObject_class, JSB_PFObject_object, NULL);
	JSB_PFObject *proxy = [[JSB_PFObject alloc] initWithJSObject:jsobj class:[PFObject class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * PFUser
 */
#pragma mark - PFUser

JSClass* JSB_PFUser_class = NULL;
JSObject* JSB_PFUser_object = NULL;
// Constructor
JSBool JSB_PFUser_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_PFUser createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_PFUser_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (PFUser)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_PFUser_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_PFUser *proxy = [[JSB_PFUser alloc] initWithJSObject:obj class:[PFUser class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: PFUser* (o)
JSBool JSB_PFUser_become__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	PFUser* ret_val;

	ret_val = [PFUser become:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: void (None)
JSBool JSB_PFUser_becomeInBackground__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	[PFUser becomeInBackground:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: PFUser* (o)
JSBool JSB_PFUser_currentUser_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	PFUser* ret_val;

	ret_val = [PFUser currentUser ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSString* (S)
JSBool JSB_PFUser_email(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSString* ret_val;

	PFUser *real = (PFUser*) [proxy realObj];
	ret_val = [real email ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSString( cx, (NSString*) ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_PFUser_enableAutomaticUser_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	[PFUser enableAutomaticUser ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_PFUser_isAuthenticated(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	PFUser *real = (PFUser*) [proxy realObj];
	ret_val = [real isAuthenticated ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_PFUser_isNew(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	PFUser *real = (PFUser*) [proxy realObj];
	ret_val = [real isNew ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: NSString*, NSString*
// Ret value: PFUser* (o)
JSBool JSB_PFUser_logInWithUsername_password__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	PFUser* ret_val;

	ret_val = [PFUser logInWithUsername:(NSString*)arg0 password:(NSString*)arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: NSString*, NSString*
// Ret value: void (None)
JSBool JSB_PFUser_logInWithUsernameInBackground_password__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	[PFUser logInWithUsernameInBackground:(NSString*)arg0 password:(NSString*)arg1  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_PFUser_logOut_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	[PFUser logOut ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSString* (S)
JSBool JSB_PFUser_parseClassName_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSString* ret_val;

	ret_val = [PFUser parseClassName ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSString( cx, (NSString*) ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSString* (S)
JSBool JSB_PFUser_password(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSString* ret_val;

	PFUser *real = (PFUser*) [proxy realObj];
	ret_val = [real password ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSString( cx, (NSString*) ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: PFQuery* (o)
JSBool JSB_PFUser_query_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	PFQuery* ret_val;

	ret_val = [PFUser query ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: BOOL (b)
JSBool JSB_PFUser_requestPasswordResetForEmail__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	BOOL ret_val;

	ret_val = [PFUser requestPasswordResetForEmail:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: void (None)
JSBool JSB_PFUser_requestPasswordResetForEmailInBackground__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	[PFUser requestPasswordResetForEmailInBackground:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSString* (S)
JSBool JSB_PFUser_sessionToken(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSString* ret_val;

	PFUser *real = (PFUser*) [proxy realObj];
	ret_val = [real sessionToken ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSString( cx, (NSString*) ret_val ));

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: void (None)
JSBool JSB_PFUser_setEmail_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	PFUser *real = (PFUser*) [proxy realObj];
	[real setEmail:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: void (None)
JSBool JSB_PFUser_setPassword_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	PFUser *real = (PFUser*) [proxy realObj];
	[real setPassword:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: void (None)
JSBool JSB_PFUser_setSessionToken_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	PFUser *real = (PFUser*) [proxy realObj];
	[real setSessionToken:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: void (None)
JSBool JSB_PFUser_setUsername_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	PFUser *real = (PFUser*) [proxy realObj];
	[real setUsername:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_PFUser_signUp(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	PFUser *real = (PFUser*) [proxy realObj];
	ret_val = [real signUp ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_PFUser_signUpInBackground(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	PFUser *real = (PFUser*) [proxy realObj];
	[real signUpInBackground ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: PFUser* (o)
JSBool JSB_PFUser_user_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	PFUser* ret_val;

	ret_val = [PFUser user ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSString* (S)
JSBool JSB_PFUser_username(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSString* ret_val;

	PFUser *real = (PFUser*) [proxy realObj];
	ret_val = [real username ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSString( cx, (NSString*) ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: PFUser* (o)
JSBool JSB_PFUser_object_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	PFUser* ret_val;

	ret_val = [PFUser object ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: PFUser* (o)
JSBool JSB_PFUser_objectWithoutDataWithObjectId__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	PFUser* ret_val;

	ret_val = [PFUser objectWithoutDataWithObjectId:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_PFUser_registerSubclass_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	[PFUser registerSubclass ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

void JSB_PFUser_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_PFUser_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_PFUser_class->name = name;
	JSB_PFUser_class->addProperty = JS_PropertyStub;
	JSB_PFUser_class->delProperty = JS_DeletePropertyStub;
	JSB_PFUser_class->getProperty = JS_PropertyStub;
	JSB_PFUser_class->setProperty = JS_StrictPropertyStub;
	JSB_PFUser_class->enumerate = JS_EnumerateStub;
	JSB_PFUser_class->resolve = JS_ResolveStub;
	JSB_PFUser_class->convert = JS_ConvertStub;
	JSB_PFUser_class->finalize = JSB_PFUser_finalize;
	JSB_PFUser_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getEmail", JSB_PFUser_email, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("isAuthenticated", JSB_PFUser_isAuthenticated, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getIsNew", JSB_PFUser_isNew, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getPassword", JSB_PFUser_password, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getSessionToken", JSB_PFUser_sessionToken, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setEmail", JSB_PFUser_setEmail_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setPassword", JSB_PFUser_setPassword_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setSessionToken", JSB_PFUser_setSessionToken_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setUsername", JSB_PFUser_setUsername_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("signUp", JSB_PFUser_signUp, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("signUpInBackground", JSB_PFUser_signUpInBackground, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getUsername", JSB_PFUser_username, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_PFUser_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("become", JSB_PFUser_become__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("becomeInBackground", JSB_PFUser_becomeInBackground__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("currentUser", JSB_PFUser_currentUser_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("enableAutomaticUser", JSB_PFUser_enableAutomaticUser_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("logInWithUsernamePassword", JSB_PFUser_logInWithUsername_password__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("logInWithUsernameInBackgroundPassword", JSB_PFUser_logInWithUsernameInBackground_password__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("logOut", JSB_PFUser_logOut_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("parseClassName", JSB_PFUser_parseClassName_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("query", JSB_PFUser_query_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("requestPasswordResetForEmail", JSB_PFUser_requestPasswordResetForEmail__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("requestPasswordResetForEmailInBackground", JSB_PFUser_requestPasswordResetForEmailInBackground__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("user", JSB_PFUser_user_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("object", JSB_PFUser_object_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("objectWithoutDataWithObjectId", JSB_PFUser_objectWithoutDataWithObjectId__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("registerSubclass", JSB_PFUser_registerSubclass_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_PFUser_object = JS_InitClass(cx, globalObj, JSB_PFObject_object, JSB_PFUser_class, JSB_PFUser_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_PFUser

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_PFUser_class, JSB_PFUser_object, NULL);
	JSB_PFUser *proxy = [[JSB_PFUser alloc] initWithJSObject:jsobj class:[PFUser class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * PFGeoPoint
 */
#pragma mark - PFGeoPoint

JSClass* JSB_PFGeoPoint_class = NULL;
JSObject* JSB_PFGeoPoint_object = NULL;
// Constructor
JSBool JSB_PFGeoPoint_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_PFGeoPoint createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_PFGeoPoint_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (PFGeoPoint)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_PFGeoPoint_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_PFGeoPoint *proxy = [[JSB_PFGeoPoint alloc] initWithJSObject:obj class:[PFGeoPoint class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: PFGeoPoint*
// Ret value: double (d)
JSBool JSB_PFGeoPoint_distanceInKilometersTo_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	double ret_val;

	PFGeoPoint *real = (PFGeoPoint*) [proxy realObj];
	ret_val = [real distanceInKilometersTo:arg0  ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: PFGeoPoint*
// Ret value: double (d)
JSBool JSB_PFGeoPoint_distanceInMilesTo_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	double ret_val;

	PFGeoPoint *real = (PFGeoPoint*) [proxy realObj];
	ret_val = [real distanceInMilesTo:arg0  ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: PFGeoPoint*
// Ret value: double (d)
JSBool JSB_PFGeoPoint_distanceInRadiansTo_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	double ret_val;

	PFGeoPoint *real = (PFGeoPoint*) [proxy realObj];
	ret_val = [real distanceInRadiansTo:arg0  ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: PFGeoPoint* (o)
JSBool JSB_PFGeoPoint_geoPoint_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	PFGeoPoint* ret_val;

	ret_val = [PFGeoPoint geoPoint ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: double, double
// Ret value: PFGeoPoint* (o)
JSBool JSB_PFGeoPoint_geoPointWithLatitude_longitude__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	PFGeoPoint* ret_val;

	ret_val = [PFGeoPoint geoPointWithLatitude:(double)arg0 longitude:(double)arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: double (d)
JSBool JSB_PFGeoPoint_latitude(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	double ret_val;

	PFGeoPoint *real = (PFGeoPoint*) [proxy realObj];
	ret_val = [real latitude ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: double (d)
JSBool JSB_PFGeoPoint_longitude(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	double ret_val;

	PFGeoPoint *real = (PFGeoPoint*) [proxy realObj];
	ret_val = [real longitude ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: double
// Ret value: void (None)
JSBool JSB_PFGeoPoint_setLatitude_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	PFGeoPoint *real = (PFGeoPoint*) [proxy realObj];
	[real setLatitude:(double)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: double
// Ret value: void (None)
JSBool JSB_PFGeoPoint_setLongitude_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	PFGeoPoint *real = (PFGeoPoint*) [proxy realObj];
	[real setLongitude:(double)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

void JSB_PFGeoPoint_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_PFGeoPoint_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_PFGeoPoint_class->name = name;
	JSB_PFGeoPoint_class->addProperty = JS_PropertyStub;
	JSB_PFGeoPoint_class->delProperty = JS_DeletePropertyStub;
	JSB_PFGeoPoint_class->getProperty = JS_PropertyStub;
	JSB_PFGeoPoint_class->setProperty = JS_StrictPropertyStub;
	JSB_PFGeoPoint_class->enumerate = JS_EnumerateStub;
	JSB_PFGeoPoint_class->resolve = JS_ResolveStub;
	JSB_PFGeoPoint_class->convert = JS_ConvertStub;
	JSB_PFGeoPoint_class->finalize = JSB_PFGeoPoint_finalize;
	JSB_PFGeoPoint_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("distanceInKilometersTo", JSB_PFGeoPoint_distanceInKilometersTo_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("distanceInMilesTo", JSB_PFGeoPoint_distanceInMilesTo_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("distanceInRadiansTo", JSB_PFGeoPoint_distanceInRadiansTo_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getLatitude", JSB_PFGeoPoint_latitude, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getLongitude", JSB_PFGeoPoint_longitude, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setLatitude", JSB_PFGeoPoint_setLatitude_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setLongitude", JSB_PFGeoPoint_setLongitude_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_PFGeoPoint_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("geoPoint", JSB_PFGeoPoint_geoPoint_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("geoPointWithLatitudeLongitude", JSB_PFGeoPoint_geoPointWithLatitude_longitude__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_PFGeoPoint_object = JS_InitClass(cx, globalObj, JSB_NSObject_object, JSB_PFGeoPoint_class, JSB_PFGeoPoint_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_PFGeoPoint

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_PFGeoPoint_class, JSB_PFGeoPoint_object, NULL);
	JSB_PFGeoPoint *proxy = [[JSB_PFGeoPoint alloc] initWithJSObject:jsobj class:[PFGeoPoint class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * PFFile
 */
#pragma mark - PFFile

JSClass* JSB_PFFile_class = NULL;
JSObject* JSB_PFFile_object = NULL;
// Constructor
JSBool JSB_PFFile_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_PFFile createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_PFFile_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (PFFile)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_PFFile_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_PFFile *proxy = [[JSB_PFFile alloc] initWithJSObject:obj class:[PFFile class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_PFFile_cancel(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	PFFile *real = (PFFile*) [proxy realObj];
	[real cancel ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSString*, NSString*
// Ret value: PFFile* (o)
JSBool JSB_PFFile_fileWithName_contentsAtPath__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	PFFile* ret_val;

	ret_val = [PFFile fileWithName:(NSString*)arg0 contentsAtPath:(NSString*)arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_PFFile_isDataAvailable(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	PFFile *real = (PFFile*) [proxy realObj];
	ret_val = [real isDataAvailable ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_PFFile_isDirty(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	PFFile *real = (PFFile*) [proxy realObj];
	ret_val = [real isDirty ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSString* (S)
JSBool JSB_PFFile_name(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSString* ret_val;

	PFFile *real = (PFFile*) [proxy realObj];
	ret_val = [real name ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSString( cx, (NSString*) ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_PFFile_save(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	PFFile *real = (PFFile*) [proxy realObj];
	ret_val = [real save ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_PFFile_saveInBackground(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	PFFile *real = (PFFile*) [proxy realObj];
	[real saveInBackground ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSString* (S)
JSBool JSB_PFFile_url(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSString* ret_val;

	PFFile *real = (PFFile*) [proxy realObj];
	ret_val = [real url ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSString( cx, (NSString*) ret_val ));

	return JS_TRUE;
}

void JSB_PFFile_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_PFFile_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_PFFile_class->name = name;
	JSB_PFFile_class->addProperty = JS_PropertyStub;
	JSB_PFFile_class->delProperty = JS_DeletePropertyStub;
	JSB_PFFile_class->getProperty = JS_PropertyStub;
	JSB_PFFile_class->setProperty = JS_StrictPropertyStub;
	JSB_PFFile_class->enumerate = JS_EnumerateStub;
	JSB_PFFile_class->resolve = JS_ResolveStub;
	JSB_PFFile_class->convert = JS_ConvertStub;
	JSB_PFFile_class->finalize = JSB_PFFile_finalize;
	JSB_PFFile_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("cancel", JSB_PFFile_cancel, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getIsDataAvailable", JSB_PFFile_isDataAvailable, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getIsDirty", JSB_PFFile_isDirty, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getName", JSB_PFFile_name, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("save", JSB_PFFile_save, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("saveInBackground", JSB_PFFile_saveInBackground, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getUrl", JSB_PFFile_url, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_PFFile_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("fileWithNameContentsAtPath", JSB_PFFile_fileWithName_contentsAtPath__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_PFFile_object = JS_InitClass(cx, globalObj, JSB_NSObject_object, JSB_PFFile_class, JSB_PFFile_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_PFFile

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_PFFile_class, JSB_PFFile_object, NULL);
	JSB_PFFile *proxy = [[JSB_PFFile alloc] initWithJSObject:jsobj class:[PFFile class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end
